package services;

import model.ListNode;

import java.util.List;

public interface ILeetCode {
    int romanToInt(String roman);
    String longestCommonPrefix(String[] strs);
    boolean isValid(String s);
    ListNode mergeTwoLists(ListNode list1, ListNode list2);
    int removeDuplicates(int[] nums);
    int removeElement(int[] nums, int val);
    int strStr(String haystack, String needle);
    int searchInsert(int[] nums, int target);
    int lengthOfLastWord(String s);
    int[] plusOne(int[] digits);
    String addBinary(String a, String b);
    int mySqrt(int x);
    int climbStairs(int n);
    List<List<Integer>> generate(int numRows);
    LinkedListNode nthToLast(LinkedListNode head, int n);
    ListNode deleteDuplicates(ListNode head);
    void merge(int[] nums1, int m, int[] nums2, int n);
    List<Integer> getRow(int rowIndex);
    int maxProfit(int[] prices);
    boolean isPalindrome(String s);
    long maximumSubarraySum(int[] nums, int k);
    int smallestSubWithSum(int arr[], int n, int x);
    int singleNumber(int[] nums);
    boolean hasCycle(ListNode head);
    int countUnguarded(int m, int n, int[][] guards, int[][] walls);
    int[] decrypt(int[] code, int k);
    long maxMatrixSum(int[][] matrix);
    int shortestSubarray(int[] nums, int k);
    boolean rotateString(String s, String goal);
    int majorityElement(int[] nums);
    ListNode removeElements(ListNode head, int val);
    int countPrimes(int n);
    boolean isHappy(int n);
    String makeFancyString(String s);
    boolean isIsomorphic(String s, String t);
    ListNode reverseList(ListNode head);
    boolean containsDuplicate(int[] nums);
    boolean isPowerOfTwo(int n);
    int missingNumber(int[] nums);
    int reverse(int x);
    String intToRoman(int num);
    int coinChange(int[] coins, int amount);
    boolean checkIfExist(int[] arr);
    int isPrefixOfWord(String sentence, String searchWord);
    String addSpaces(String s, int[] spaces);
    int lengthOfLongestSubstring(String s);
    boolean canMakeSubsequence(String str1, String str2);
    String longestPalindrome(String s);
    int maxArea(int[] height);
    int maxSubArray(int[] nums);
    boolean canChange(String start, String target);
    int maxCount(int[] banned, int n, int maxSum);
    String compressedString(String word);
    boolean canMeasureWater(int x, int y, int target);
    int maximumBeauty(int[] nums, int k);
    long pickGifts(int[] gifts, int k);
    int[] finalPrices(int[] prices);
    boolean hasDuplicate(int[] nums);
    boolean isAnagram(String s, String t);
    int[] twoSum(int[] nums, int target);
    List<List<String>> groupAnagrams(String[] strs);
    int[] topKFrequent(int[] nums, int k);
    int[] productExceptSelf(int[] nums);
    int[] runningSum(int[] nums);
    int maximumWealth(int[][] accounts);
    String mergeAlternately(String word1, String word2);
    int maxProfitV2(int[] prices);
    void rotate(int[] nums, int k);
    int prefixCount(String[] words, String pref);
    int[] findThePrefixCommonArray(int[] A, int[] B);
    String gcdOfStrings(String str1, String str2);
    List<Boolean> kidsWithCandies(int[] candies, int extraCandies);
    boolean canPlaceFlowers(int[] flowerbed, int n);
    String reverseVowels(String s);
    String reverseWords(String s);
    String frequencySort(String s);
    int jumpingOnClouds(int[] c, int k);
    int[][] highestPeak(int[][] isWater);
    int countServers(int[][] grid);
    boolean check(int[] nums);
    int maxAscendingSum(int[] nums);
    boolean areAlmostEqual(String s1, String s2);
    void moveZeroes(int[] nums);
    boolean isSubsequence(String s, String t);
    double findMaxAverage(int[] nums, int k);
    int tupleSameProduct(int[] nums);
    int maxVowels(String s, int k);
    String clearDigits(String s);
    int[] queryResults(int limit, int[][] queries);
    String removeOccurrences(String s, String part);
    long countBadPairs(int[] nums);
    int maximumSum(int[] nums);
    boolean isArraySpecial(int[] nums);
}
